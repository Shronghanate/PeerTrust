/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-related
 * data is stored within a dedicated user document tree, ensuring that users can only
 * access their own information.
 *
 * Data Structure: All data is nested under the top-level `/users` collection, with a
 * structure of `/users/{userId}/{subcollection}/{documentId}`. This path-based ownership
 * allows for simple, performant, and secure authorization checks without needing to read
 * other documents.
 *
 * Key Security Decisions:
 * - User Enumeration Disabled: Listing the top-level `/users` collection is explicitly
 *   denied to protect user privacy.
 * - Profile Visibility: User profiles are readable by any authenticated user to facilitate
 *   app interactions, but are only writable by the owner.
 * - Cross-User Writes: The system safely allows specific cross-user write operations, such
 *   as one user submitting feedback for another. This is secured by validating that the
 *   creator's ID is correctly embedded in the new document.
 * - Shared Access: Feedback requests are accessible to both the requester and the requestee,
 *   enabling collaboration while restricting access to only the involved parties.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the requesting user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    /**
     * Verifies that a document already exists.
     * Crucial for protecting update and delete operations from acting on non-existent paths.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership and existence checks for update/delete operations.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow (get) Any authenticated user can view any user's profile.
     * @allow (create) An authenticated user can create their own profile document. `auth.uid: 'user_abc'`, `path: /users/user_abc`
     * @deny (list) Listing all users is disabled to prevent user enumeration.
     * @deny (create) A user cannot create a profile for another user. `auth.uid: 'user_abc'`, `path: /users/user_xyz`
     * @principle Enforces self-creation and document ownership for writes, while allowing reads for discoverability.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages a user's logged interactions with peers.
       * @path /users/{userId}/interactions/{interactionId}
       * @allow (create) The owner of the path can create an interaction document for themselves.
       * @deny (get) A user cannot read another user's private interaction history.
       * @principle Restricts access to a user's own data tree.
       */
      match /interactions/{interactionId} {
        allow get, list: if isOwner(userId);
        allow create: if isOwner(userId) && (request.resource.data.participant1Id == userId || request.resource.data.participant2Id == userId);
        allow update: if isExistingOwner(userId) && request.resource.data.participant1Id == resource.data.participant1Id && request.resource.data.participant2Id == resource.data.participant2Id;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages feedback documents *received* by a user. The {userId} in the path is the reviewee.
       * @path /users/{userId}/feedback/{feedbackId}
       * @allow (create) An authenticated user can create feedback for another user. `auth.uid: 'reviewer_123'`, `path: /users/reviewee_456/feedback/abc`, `data: { reviewerId: 'reviewer_123', revieweeId: 'reviewee_456' }`
       * @allow (get) A user can read the feedback they have received. `auth.uid: 'reviewee_456'`, `path: /users/reviewee_456/feedback/abc`
       * @deny (get) A user cannot read feedback another user has received. `auth.uid: 'user_789'`, `path: /users/reviewee_456/feedback/abc`
       * @deny (update) The original reviewer cannot modify feedback after submitting it.
       * @principle Secures a cross-user write by validating sender identity, while giving the recipient full control over the received document.
       */
      match /feedback/{feedbackId} {
        allow get, list: if isOwner(userId);
        allow create: if isSignedIn() && request.resource.data.revieweeId == userId && request.resource.data.reviewerId == request.auth.uid;
        allow update: if isExistingOwner(userId) && request.resource.data.reviewerId == resource.data.reviewerId && request.resource.data.revieweeId == resource.data.revieweeId;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Manages feedback requests *sent* by a user. The {userId} in the path is the requester.
       * @path /users/{userId}/feedbackRequests/{feedbackRequestId}
       * @allow (get) The requester or the requestee can read a feedback request.
       * @allow (create) A user can create a feedback request in their own subcollection. `auth.uid: 'requester_123'`, `path: /users/requester_123/feedbackRequests/xyz`
       * @deny (delete) The requestee cannot delete a request sent to them.
       * @principle Implements shared access between two parties (requester and requestee) for reads and updates.
       */
      match /feedbackRequests/{feedbackRequestId} {
        allow get: if isExistingDoc() && (isOwner(resource.data.requesterId) || isOwner(resource.data.requesteeId));
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.requesterId == userId;
        allow update: if isExistingDoc() && (isOwner(resource.data.requesterId) || isOwner(resource.data.requesteeId)) && request.resource.data.requesterId == resource.data.requesterId && request.resource.data.requesteeId == resource.data.requesteeId;
        allow delete: if isExistingOwner(userId);
      }
    }
  }
}